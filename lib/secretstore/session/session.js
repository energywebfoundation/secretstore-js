/** @module secretstore/session */
"use strict";

const utils = require("../../utils.js");

/**
 * Thrown when an error has occured during the Secret Store session.
 * 
 * @memberof module:secretstore/session
 * @class
 */
class SecretStoreSessionError extends Error {
    /**
     * @constructor
     * @param {String} message The error message.
     * @param {Object} response The response object.
     */
    constructor(message, response) {
        super(message);
        this.response = response;
        this.name = "SecretStoreSessionError";
    }
};

/**
 * The class holding together the secretstore session calls.
 * 
 * @memberof module:secretstore/session
 * @class
 */
class Session {

    /**
     * 
     * @param {String} ss_endpoint_uri The HTTP endpoint URI where the Secret Store node is listening for incoming session requests.
     */
    constructor(ss_endpoint_uri) {
        if (!ss_endpoint_uri) {
            throw new Error("Secret Store enpoint URI was not given, or invalid: " + ss_endpoint_uri);
        }
        if (ss_endpoint_uri.endsWith("/")) {
            this.uri = ss_endpoint_uri.slice(0, -1);
        } else {
            this.uri = ss_endpoint_uri;
        }
    }

    /**
     * Generates server keys.
     * 
     * [More here.]{@link https://wiki.parity.io/Secret-Store.html#server-key-generation-session}
     * 
     * @param {String} serverKeyID The server key ID of your choosing. If you’re planning to link document key to this server key later, it would be good to use document contents hash as this identifier. Otherwise, it could be a random value. In both cases, please note that this value is unique and cannot be changed later.
     * @param {String} signedServerKeyID The server key ID, signed with author’s private key. Only the author of a server key could bind document key to this server key later. This signature could be generated by secretstore_signRawHash RPC method.
     * @param {Number} threshold The key threshold value. Please consider the 
     * [guidelines]{@link https://wiki.parity.io/Secret-Store.html#server-key-generation-session} when choosing this value.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} The hex-encoded public portion of the server key.
     */
    generateServerKey(serverKeyID, signedServerKeyID, threshold, verbose = true) {

        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/shadow/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID) + "/" + threshold,
                method: 'POST'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }

    /**
     * Retrieves the public portion of an already generated server key.
     * 
     * Useable after a [successful server key generation session]{@link https://wiki.parity.io/Secret-Store.html#server-key-generation-session}, 
     * and has to be performed by the same user who generated the server key.
     * 
     * @param {String} serverKeyID The ID of previously generated server key.
     * @param {String} signedServerKeyID The hex-encoded server key ID, signed by the same entity (author) that has signed the server key ID in server key generation session.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} The hex-encoded public portion of the server key.
     */
    retrieveServerKeyPublic(serverKeyID, signedServerKeyID, verbose = true) {

        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/server/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID),
                method: 'GET'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }


    /**
     * Binds an externally-generated document key to a server key.
     * 
     * Useable after a [server key generation session]{@link https://wiki.parity.io/Secret-Store#server-key-generation-session}.
     * [More here.]{@link https://wiki.parity.io/Secret-Store#document-key-storing-session}
     * 
     * @param {String} serverKeyID The hex-encoded server key ID, the same that was used in the server key generation session.
     * @param {String} signedServerKeyID The hex-encoded server key ID, signed by the same entity (author) that has signed the server key id in server key generation session.
     * @param {String} commonPoint The hex-encoded common point portion of the externally encrypted document key (by public server key, using special procedure).
     * @param {String} encryptedPoint The hex-encoded encrypted point portion of the externally encrypted document key (by public server key, using special procedure).
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} Empty string if everything was OK (status code 200).
     */
    storeDocumentKey(serverKeyID, signedServerKeyID, commonPoint, encryptedPoint, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/shadow/" + utils.remove0x(serverKeyID)
                    + "/" + utils.remove0x(signedServerKeyID)
                    + "/" + utils.remove0x(commonPoint)
                    + "/" + utils.remove0x(encryptedPoint),
                method: 'POST'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(body);
                }
            });
        });
    }


    /**
     * 
     * Generating server and document keys by one of the participating nodes with one call.
     * 
     * You can generate both keys simultaneously, but if you’re not trusting the Secret Store nodes, it is advised 
     * to run separate server key generation and document key storing sessions.
     * [More here.]{@link https://wiki.parity.io/Secret-Store#server-and-document-key-generation-session}
     * 
     * @param {String} serverKeyID The server key ID of your choosing. It would be good to use document contents hash as this identifier. Otherwise, it could be a random value. In both cases, please note that this value is unique and cannot be changed later.
     * @param {String} signedServerKeyID The server key ID, signed with author’s private key.
     * @param {Number} threshold The key threshold value. Please consider the 
     * [guidelines]{@link https://wiki.parity.io/Secret-Store.html#server-key-generation-session} when choosing this value.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} The hex-encoded document key, encrypted with requester’s public key (ECIES encryption is used).
     */
    generateServerAndDocumentKey(serverKeyID, signedServerKeyID, threshold, verbose = true) {

        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID) + "/" + threshold,
                method: 'POST'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }

    /**
     * Fetches the document key from the secret store.
     * 
     * This session is a preferable way of retrieving the previously generated document key. During document key shadow retrieval 
     * session, document key is not reconstructed on any node, but it requires Secret Store client either to have access to Parity RPCs, 
     * or to run some EC calculations to decrypt the document key.
     * 
     * Please note that the requester must have permission to access this key. Permissions are often managed by a permissioning contract.
     * 
     * [More here.]{@link https://wiki.parity.io/Secret-Store#document-key-shadow-retrieval-session}
     * 
     * @param {String} serverKeyID The ID of previously generated server key, to which the document key has been bound.
     * @param {String} signedServerKeyID The server key ID, signed with the private key of requester, having access to the server key.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<Object>} The hex-encoded decrypted_secret, common_point and decrypt_shadows fields. To reconstruct the document key, Secret Store client must pass values of these fields to a secretstore_shadowDecrypt RPC call.
     */
    shadowRetrieveDocumentKey(serverKeyID, signedServerKeyID, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/shadow/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID),
                method: 'GET'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(JSON.parse(body));
                }
            });
        });
    }

    /**
     * 
     * Fetches the document key from the Secret Store.
     * 
     * This is the lighter version of the [document key shadow retrieval session]{@link https://wiki.parity.io/Secret-Store#document-key-shadow-retrieval-session}, 
     * which returns the final document key (encrypted with the requester's public key). 
     * You must have enough trust in the Secret Store nodes for this. During document key shadow retrieval 
     * session, document key is not reconstructed on any node, but it requires the Secret Store client 
     * either to have access to Parity RPCs, or to run some EC calculations to decrypt the document key.
     * 
     * Please note that the requester must have permission to access this key. Permissions are often managed by a permissioning contract.
     * 
     * [More here.]{@link https://wiki.parity.io/Secret-Store#document-key-retrieval-session}
     * 
     * @param {String} serverKeyID The ID of previously generated server key, to which document key has been bound.
     * @param {String} signedServerKeyID The server key ID, signed with the private key of requester, having access to the server key.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} The hex-encoded document key, encrypted with requester's public key (ECIES encryption is used).
     */
    retrieveDocumentKey(serverKeyID, signedServerKeyID, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID),
                method: 'GET'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }

    /**
     * Schnorr signing session, for computing Schnorr signature of a given 256-bit message hash.
     * 
     * [More here.]{@link https://wiki.parity.io/Secret-Store#schnorr-signing-session}
     * 
     * @param {String} serverKeyID The previously generated hex-encoded server key ID.
     * @param {String} signedServerKeyID The hex-encoded, previously generated server key ID, signed with the private key of requester, having access to the server key.
     * @param {String} messageHash The 256-bit hash of the message that needs to be signed.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<String>} The hex-encoded Schnorr signature (serialized as c || s), 
     * encrypted with requester's public key (ECIES encryption is used).
     */
    signSchnorr(serverKeyID, signedServerKeyID, messageHash, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/schnorr/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID) + "/" + messageHash,
                method: 'GET'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }

    /**
     * ECDSA signing session, for computing ECDSA signature of a given 256-bit message hash.
     * 
     * [More here.]{@link https://wiki.parity.io/Secret-Store#ecdsa-signing-session}
     * 
     * @param {String} serverKeyID The previously generated hex-encoded server key ID.
     * @param {String} signedServerKeyID The hex-encoded, previously generated server key ID signed with the private key of requester, having access to the server key.
     * @param {String} messageHash The 256-bit hash of the message that needs to be signed.
     * @param {Boolean} verbose Whether to console log errors.
     * @return {Promise<String>} The hex-encoded ECDSA signature (serialized as r || s || v ), encrypted with requester public key (ECIES encryption is used).
     */
    signEcdsa(serverKeyID, signedServerKeyID, messageHash, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/ecdsa/" + utils.remove0x(serverKeyID) + "/" + utils.remove0x(signedServerKeyID) + "/" + messageHash,
                method: 'GET'
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }


    /**
     * 
     * Node set change session.
     * 
     * Please follow the description [here]{@link https://wiki.parity.io/Secret-Store-Configuration.html#changing-the-configuration-of-a-set-of-servers} 
     * on how to perform this session.
     * 
     * Requires all added, removed and stable nodes to be online for the duration 
     * of the session. Before starting the session, you’ll need to generate two administrator’s 
     * signatures: old set signature and new set signature. To generate these signatures, 
     * the Secret Store RPC methods should be used: serversSetHash and signRawHash.
     * 
     * @param {String} nodeIDsNewSet Node IDs of the *new set*.
     * @param {String} signatureOldSet ECDSA signature of all online node IDs *keccak(ordered_list(staying + added + removing))*.
     * @param {String} signatureNewSet ECDSA signature of node IDs that should stay in the Secret Store cluster after the session ends *keccak(ordered_list(staying + added))*.
     * @param {Boolean} verbose Whether to console log errors.
     * @returns {Promise<Object>} Empty string if everything was OK (status code 200).
     */
    nodesSetChange(nodeIDsNewSet, signatureOldSet, signatureNewSet, verbose = true) {
        return new Promise((resolve, reject) => {
            const request = require('request');

            var options = {
                url: this.uri + "/admin/servers_set_change"
                    + "/" + utils.remove0x(signatureOldSet)
                    + "/" + utils.remove0x(signatureNewSet),
                method: 'POST',
                body: JSON.stringify(nodeIDsNewSet)
            };

            request(options, (error, response, body) => {
                if (error) {
                    if (verbose) utils.logError(error);
                    reject(error);
                }
                else if (response.statusCode != 200) {
                    if (verbose) utils.logFailedResponse(response, body, options);
                    var sserror = new SecretStoreSessionError("Request failed.", response);
                    reject(sserror);
                }
                else {
                    resolve(utils.removeEnclosingDQuotes(body));
                }
            });
        });
    }
};

module.exports = {
    Session,
    SecretStoreSessionError
}